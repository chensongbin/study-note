#并发编程

如何减少上下文切换

- 无锁并发编程

  eg:将数据的ID按照hash算法取模分段，不同的线程处理不同段的数据

- CAS算法

- 使用最少的线程

- 协程

  在单线程里实现多任务的调度，并在单个线程里维持多个任务的切换





volatile

功能：可见性，禁止重排序

底层原理：

volatile变量修饰的共享变量进行写操作时会多出一行汇编代码

Lock前缀指令在多核处理器下会引发两个操作：

1）将当前处理器缓存行的数据写回到内存

2）这个写回操作，会使在其他CPU里缓存了该内存地址的数据无效

```java
//java 代码如下
instance = new Singleton(); // instance是volatile变量

// 汇编如下
0x01a3de1d: movb $0×0,0×1104800(%esi);
0x01a3de24: lock addl $0×0,(%esp);	// 多出一行
```





sychronized





编译后，会插入monitorenter 和 monitorexit 指令



锁在哪？

sychronized 用的锁存在 Java对象头里

如果对象是数组类型，对象头大小3个字宽（word）

非数组类型，对象头2个字宽（word）

> 注意：32位虚拟机1字宽=4字节



对象头

| 长度      | 内容                   | 说明                         |
| --------- | ---------------------- | ---------------------------- |
| 32/64 bit | Mark Word              | 根据对象的状态确定           |
| 32/64 bit | Class Metadata Address | 指向对象的类型               |
| 32/64 bit | Array length           | 数组的长度（如果是数组对象） |



锁的升级

jdk1.6 优化了锁，为了减少获得锁和释放锁的带来的性能消耗，引入了偏向锁和轻量级锁

锁的四种状态级别由低到高（可以升级不可以降级）

- 无锁状态
- 偏向锁状态  （锁多次被同一个线程拿着）
- 轻量级锁状态 （自旋）
- 重量级锁状态

除了重量级锁，其他锁可以看出乐观锁

[Java中的锁 ](https://blog.csdn.net/zqz_zqz/article/details/70233767)





happen-before

A操作 一个操作执行的结果需要对另一个操作可见







# cha4 Java并发编程的基础

sychronnized块与sychronized方法的实现

- 同步块：monitorenter 和 monitorexit 指令
- 同步方法依靠方法修饰符上的ACC_SYNCHRONIZED

无论哪种方式，本质是对一个对象的监视器（monitor）进行获取







## Thread.join()原理

本质是使用了wait/notify机制

当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程

```java
// 当前对象加锁
public final synchronized void join() throws InterruptedException {
	// 条件不满足（即线程还没终止），继续等待
    while (isAlive()) {
        wait(0);
    }
	// 线程终止，方法返回
}
```





# cha5 Java中的锁

## Lock接口

```java
public interface Lock {
    void lock();
	// 与lock()不同就是获取到锁之后会响应中断，被中断之后会抛出异常并且释放锁 
    void lockInterruptibly() throws InterruptedException;
	// 非阻塞地获取锁，调用该方法后会立即返回
    boolean tryLock();
	// 在给定地时间内，（1）获取到锁返回（2）超时返回 （3）在时间内被中断
    boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;
	// 释放锁
    void unlock();
	// 该组件和当前锁绑定，线程只有获得锁，才能调用该组件的wait()方法，调用后，锁会被释放
    Condition newCondition();
}
```





如何使用：

在finally块中释放锁，保证

```java
Lock lock = new ReentrantLock();
lock.lock();
try{
    
}finally{
    lock.unlock();
}
```



## 队列同步器

