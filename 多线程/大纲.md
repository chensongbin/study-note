# 线程相关





# Java中的锁

## sychronized





## ReentrantLock







# 相同

都是可重入锁



## 区别

**1. 锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。



# 用锁的最佳实践

首先你的代码是否会被多线程调用？

否：无需加锁

有：参考如下原则：

1. 永远只在**更新对象的成员变量**时加锁

2. 永远只在**访问可变的成员变量**时加锁

   > 解释：在一些场景，对一致性要求不高，读成员变量可以不加锁

3. 永远不在调用其它对象的方法时加锁，因为调用其它对象的方法是不安全的（对其它对象的方法不了解）

   - 可能有Thread.sleep()，也有可能有慢IO，这会**严重影响性能**
   - 甚至还会加锁，这有可能导致**死锁**

4. 减少锁的**持有时间**

5. 减少**锁粒度**







# 线程之间的协作





# J.U.C - AQS



# J.U.C  并发容器







#J.U.C  并发工具

## Semaphore(信号量)



## ReadWriteLock(读写锁)



## StampedLock



## CountDownLatch



## CyclicBarrier(同步屏障)





## 原子类





# J.U.C  阻塞队列





#J.U.C  线程池 







# Java内存模型



