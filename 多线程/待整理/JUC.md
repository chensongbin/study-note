# 多线程

## Java线程的生命周期

> 注意与操作系统的线程生命周期做区别：

线程调用阻塞式API时，是否会转换到BLOCKED状态呢？

在操作系统层面，线程是会转换到休眠状态的，但是在JVM层面，Java线程的状态不会发生变化，也就是说Java线程的状态会依然保持RUNNABLE状态。

而我们平时所谓的Java在调用阻塞式API时，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态。



## 停止线程

一、stop()

已经弃用，stop()方法会真的杀死线程，不给线程喘息的机会，如果线程持有ReentrantLock锁，被stop()的线程并不会自动调用ReentrantLock的unlock()去释放锁，那其他线程就再也没机会获得ReentrantLock锁



二、interrupt()

1. 异常

   当线程A处于WAITING、TIMED_WAITING状态时，如果其他线程调用线程A的interrupt()方法，会使线程A返回到RUNNABLE状态，同时线程A的代码会触发InterruptedException异常。

2. 主动检查

   主动检测，如果线程处于RUNNABLE状态，并且没有阻塞在某个I/O操作上，例如中断计算圆周率的线程A，这时就得依赖线程A主动检测中断状态了。如果其他线程调用线程A的interrupt()方法，那么线程A可以通过isInterrupted()方法，检测是不是自己被中断了。



## 创建多少线程合适

一、CPU密集型

理论上“线程的数量=CPU核数。

在工程上，线程的数量 = CPU核数+1，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证CPU的利用率。



二、I/O密集型

最佳线程数=CPU核数 * [ 1 +（I/O耗时 / CPU耗时）]

> IO耗时和CPU耗时的比值是一个关键参数，不幸的是这个参数是未知的，而且是动态变化的，所以工程上，我们要估算这个参数，然后做各种不同场景下的压测来验证我们的估计



得出上述公式的本质：

将硬件的性能发挥到极致，也就是cpu、io利用率100%





# 并发编程

## 出现的问题

可见性、有序性 ------ Java内存模型

原子性 ----- 锁解决原子性问题



## 安全性问题

数据竞争： 多个线程同时访问一个数据，并且至少有一个线程会写这个数据。
竞态条件： 程序的执行结果依赖程序执行的顺序。

```java
//也可以按照以下的方式理解竞态条件： 
//程序的执行依赖于某个状态变量，在判断满足条件的时候执行，但是在执行时其他变量同时修改了状态变量。
if (状态变量 满足 执行条件) {
	执行操作
}
```



## 活跃性问题

所谓活跃性问题，指的是某个操作无法执行下去

包括：

- **死锁**

  - 解决：破坏死锁的四个必要条件
    1. 互斥无法破坏，使用锁就是为了保证互斥
    2. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
    3. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
    4. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。

  > 产生死锁四个必要条件：
  >
  > 1. 互斥，共享资源X和Y只能被一个线程占用；
  > 2. 占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；
  > 3. 不可抢占，其他线程不能强行抢占线程T1占有的资源；
  > 4. 循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。

- **活锁**

  - 例子：

    没有线程阻塞，但是无法推进。比如两个很有礼貌的人在同一条路上相遇，彼此给对方让路，但是又在同一条路上遇到了。互相之间反复的避让下去

  - 解决：等待一个随机时间

- **饥饿**

  - 指的是线程因无法访问所需资源而无法执行下去的情况
  - 例子：
    - 在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”
    - 持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。
  - 解决：
    - 一是保证资源充足，
    - 二是公平地分配资源，
    - 三就是避免持有锁的线程长时间执行





## 如何用面向对象思想写好并发程序

1. 将共享变量封装成类，对公共方法设置并发访问策略
2. 对于不会发生变化的共享变量，建议用final关键字来修饰
3. 注意共享变量之间的约束，比如共享变量上限up、下限low，约束是up>low
4. 



# Java内存模型





# 相关概念

## 管程

**在并发编程领域，有两大核心问题：**

- **互斥**，即同一时刻只允许一个线程访问共享资源；
- **同步**，即线程之间如何通信、协作。

**解决上述问题：**

- 信号量
- 管程

**什么是管程：**

管程，对应的英文是Monitor，其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译。

**管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发**。翻译为Java领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的

![MESA管程模型](image/MESA管程模型.png)

> 在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。
>
> 管程里还引入了条件变量的概念，而且**每个条件变量都对应有一个等待队列**
>
> 线程执行时，条件不满足时进入条件变量等待队列，条件满足之后移出队列，加入到入口等待队列中去











# CAS算法

 cas算法与加锁的效率比较

1）cas实际就是一种乐观锁，适用于读多写少

2）在写多读少的情景下，效率不如加锁 

例子：

可以写一个循环100000次 i++ 操作，验证



ABA问题：

原来值为A，线程1改为B，线程2改为A，线程3来改的时候无法判断值是否被更改

解决办法：加入版本号



# 原子变量

jdk1.5后 java.util.concurrent.atomic包下提供了常用的原子变量

实现原理：

1. 使用volatile保证内存可见性
2. 使用cas算法保证原子性



# 并发容器

ConcurrentHashMap

CopyOnWriteArrayList







# 并发工具类

CountDownLatch

CyclicBarrier

Semaphore





