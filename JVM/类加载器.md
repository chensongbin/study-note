[TOC]



# 类装载步骤

## 大纲

1. 加载

2. 连接

   （1）验证

   （2）准备

   （3）解析

3. 初始化

> 使用-XX:+TraceClassLoading参数，可以看类的装载情况



## 加载

加载类时，Java虚拟机必须完成以下工作：

- 通过类的全类名，获取类的二进制数据流
- 解析类的二进制数据流为方法区内的数据结构
- 创建java.lang.Class类的实例，表示该类型



## 验证

目的是保证加载的字节码是合法、合理并符合规范的



## 准备

为类分配响应的内存空间，并且设置，默认初始值

eg:比如 int 类型默认为0，引用类型默认为null

> 注意final字段，由于该字段在字节码文件中存在ConstantValue属性，那么该字段在准备阶段就会被赋值



## 解析

将符号引用转化为直接引用



## 初始化

### 简介

执行类的初始化方法<cint>，方法<cint>是由编译器自动生成的，它是由类静态成员的赋值语句以及static语句块合并产生的

> 对于<cint>函数的调用，虚拟机内部会加锁保证线程安全



### 类初始化条件

Java虚拟机规定，一个类或者接口在初次使用之前，必须进行初始化

分为6种情况

- 创建一个类的实例

  eg：使用new、反射、克隆、反序列化

- 调用类的静态方法时

  eg：使用invokestatic指令

- 使用类或者接口的静态字段（final常量除外）

  eg：使用getstatic、putstatic指令

  > static final 字段在准备阶段就会被赋值

- 使用java.lang.reflect包中的方法反射类的方法时

- 初始化子类时，要求先初始化父类

- 作为启动虚拟机，含有main()方法的那个类





# 类加载器

## 简介

ClassLoader是一个抽象类

类加载器负责通过各种方式

类加载器工作在加载阶段，不会影响连接、和初始化阶段



## ClassLoader的分类

- **启动类加载器**

  BootStrap ClassLoader

  完全由c语言实现，在Java代码中获取String的类加载器，返回为null（表明加载String对象的是类加载器）

  负责加载系统核心类，rt.jar

- **扩展类加载器**

  Extension ClassLoader

  %JAVA_HOME%/lib/ext/*.jar

- **应用类加载器**

  App ClassLoader

  用户程序的类

- **自定义类加载器**

![1568686663332](image/类加载器层次结构.png)



## 双亲委派模式

流程：

- 检查类是否已经加载
- 如果没有，先交给双亲加载
- 双亲不能加载，再自己加载

> 具体实现在ClassLoader中的loadClass()方法





## 双亲委派模式的弊端

检查类是否已经加载的委托是单向的（由下而上）

因此顶层的ClassLoader无法访问底层ClassLoader加载的类

> eg:



## 破坏双亲委派

重载ClassLoader，修改LoadClass的实现



## 应用

使用类加载器实现热替换

