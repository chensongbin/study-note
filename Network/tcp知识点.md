# TCP 协议如何解决粘包、半包问题

一、问题描述

粘包：发送方应用层发送了多个数据包，TCP层组装成一个 接收方应用层一次全部收取

半包：发送方的数据包分为多次发过来，收到的数据只是一个包的部分



二、出现问题的原因：

TCP 是面向字节流的；

eg:发送端A向接收端B发了300字节，B 可能先收到 100 字节，再收到 200 字节；也可能先收到 50 字节，再收到 250 字节；或者先收到 100 字节，再收到 100 字节，再收到 200 字节.......



二、如何解决：

（1）**固定包长的数据包**

协议包的长度都是固定的。举个例子，例如我们可以规定每个协议包的大小是 64 个字节，每次收满 64 个字节，就取出来解析

（2）**以指定字符（串）为包的结束标志**

这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上"\r\n"（即所谓的 **CRLF**）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。

这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。

（3**）包头 + 包体格式**

这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。





> 补充问题：网络通信时，如何解决粘包、丢包或者包乱序问题？
>
> （1）如果使用TCP，TCP保证了可靠传输，不会出现丢包、包乱序的问题，TCP 协议栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发到目的地
>
> （2）如果使用UDP，如果不能接受少量丢包，那就要自己在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了（例如 RTP协议、RUDP 协议）



四、参考

[TCP 协议如何解决粘包、半包问题](https://mp.weixin.qq.com/s/wUOrfxrO9C7tvvkXEkeQoA)





# 滑动窗口

参数：

RTT（round trip time）：发送一个数据包到收到对应ack所花费的时间

RTO（Retransmission TimeOut）即重传超时时间



作用：

- 保证TCP的可靠性
- 

